/*	File:		Template.impl.h	Contains:	Latern driver implementation header for PCMCIA Template Ethernet card				You may incorporate this sample code into your applications without				restriction.  This sample code has been provided "AS IS" and the				responsibility for its operation is 100% yours.  You are not				permitted to modify and redistribute the source as "DDK Sample Code."				If you are going to re-distribute the source, we require that you				make it clear in the source that the code was descended from				Apple-provided sample code, but that you've made changes.	Copyright:	� 1997 by Apple Computer, Inc., all rights reserved.	Obtained from NIE2.0 F1C2 build. 9/4/97*/#ifndef __TEMPLATE_IMPL_H#define __TEMPLATE_IMPL_H#ifndef	__LANTERNDRIVER_PROTO_H#include "LanternDriver.proto.h"#endif#ifndef	__LANTERNDRIVERAPI_PROTO_H#include "LanternDriverAPI.proto.h"#endif#ifndef __BUFFERLIST_H#include "BufferList.h"#endif#ifndef __NEWTONTIME_H#include "NewtonTime.h"#endif#ifdef forDebug#define kDB__pHISTORYCOLLECT		// Trace Events?#endif#ifndef __HISTORYCOLLECTORMACRO_H#include "HistoryCollectorMacro.h"#endif#define kPacketAddrSize 					(6)#define kTimerTime							(100)				// Milliseconds////	TTemplateDriver	Template Ethernet Driver driver//PROTOCOL TNE2000Sample : public TLanternDriver					// Protocol class	PROTOCOLVERSION(1.0)										// Protocol class version{	public:		//	Protocol Class Interface				PROTOCOL_IMPL_HEADER_MACRO(TNE2000Sample);				// Magic stuff, don't touch (for ProtocolGen)		TLanternDriver*	New(void);								// Protocol class constructor, called when the card is inserted		void			Delete();								// Protocol class destructor, called when the card is removed		//	Task services		NewtonErr		Init(void);								// Driver initialization 		NewtonErr		Enable();								// Start/resume card operations (startup/newton power on)		NewtonErr		Disable();								// Stop/suspend card operations (shutdown/newton power off)		void			InterruptHandler();						// Called to handle a card interrupt	private:		//	Client Services (from event handlers of TLanternDriverAPI)		void			SendBuffer(Ptr thePacket, Size size);	// Transmit a buffer		void			SendCBufferList(CBufferList* thePacket);// Transmit a CBufferList		void			GetDeviceAddress(UByte* addr, Size size); // Return the device address		void			AddMulticastAddress(UByte* addr);		// Add a multicast address		void			DelMulticastAddress(UByte* addr);		// Delete a multicast address		void			GetLinkIntegrity(void);					// Get the link integrity flag			// Optional services				void 			SetPromiscuous(ULong promiscuous);		// Set to receive in promiscous mode		void 			GetThroughput(void);					// Get a throughput statistic				// Private Template Services		void			TimerExpired(void);						// Called when driver timer expires				//	Template routines		//	Internal variables				ULong			fStatus;								// Internal status		UChar			fEthernetAddr[kPacketAddrSize];			// Ethernet address		Boolean			fLinkIntegrity;							// Link integrity staus		Boolean			fTimerPosted;							// Is a timer event posted.		TTime*			fTickTime;								// TIme for the next timer event			  #ifdef forDebug		void			DumpBuffer(UChar* buffer, ULong size, ULong startingAddr);	// Dump buffer data		EventTraceCauseDesc*	fEventTraceCauseDescs;			// Event trace cause descriptors		TEventCollector*		fEventTraceCollector;			// Event trace collector	  #endif};////	Internal status definitions//enum kStatus{	kStatusNoStatus						=	0x00000000,			// No status yet	kStatusCardPowerOn					=	0x00000001,			// Card power is truned on by us (need to turn off later)};#endif//==========================================================================================//==========================================================================================#if 0/*	File:		NE2000.impl.h	Contains:	Latern driver implementation header for PCMCIA NE2000 Ethernet card				You may incorporate this sample code into your applications without				restriction.  This sample code has been provided "AS IS" and the				responsibility for its operation is 100% yours.  You are not				permitted to modify and redistribute the source as "DDK Sample Code."				If you are going to re-distribute the source, we require that you				make it clear in the source that the code was descended from				Apple-provided sample code, but that you've made changes.	Copyright:	� 1997 by Newton, Inc., all rights reserved.	Change History (most recent first):		Obtained from NIE2.0 F1C2 build. 9/4/97*/#ifndef __NE2000_IMPL_H#define __NE2000_IMPL_H#ifndef	__LANTERNDRIVER_PROTO_H#include "LanternDriver.proto.h"#endif#ifndef	__LANTERNDRIVERAPI_PROTO_H#include "LanternDriverAPI.proto.h"#endif#ifndef	__NE2000_H#include "NE2000.h"#endifclass CList;class CBufferList;class EventTraceCauseDesc;class TEventCollector;class TTxPacketQueue;class TMulticastAddrDataBase;////	TNE2000Sample	NE2000 Ethernet sample driver//PROTOCOL TNE2000Sample : public TLanternDriver					// Protocol class	PROTOCOLVERSION(1.0)										// Protocol class version{	public:		//	Protocol Class Interface				PROTOCOL_IMPL_HEADER_MACRO(TNE2000Sample);				// Magic stuff, don't touch (for ProtocolGen)		TLanternDriver*	New(void);								// Protocol class constructor, called when the card is inserted		void			Delete();								// Protocol class destructor, called when the card is removed		//	Task services		NewtonErr		Init(void);								// Driver initialization 		NewtonErr		Enable();								// Start/resume card operations (startup/newton power on)		NewtonErr		Disable();								// Stop/suspend card operations (shutdown/newton power off)		void			InterruptHandler();						// Called to handle a card interruptprivate:		friend			class	TMulticastAddrDataBase;		//	Client Services (from event handlers of TLanternDriverAPI)		void			SendBuffer(Ptr thePacket, Size size);	// Transmit a buffer		void			SendCBufferList(CBufferList* thePacket);// Transmit a CBufferList		void			GetDeviceAddress(UByte* addr, Size size); // Return the device address		void			AddMulticastAddress(UByte* addr);		// Add a multicast address		void			DelMulticastAddress(UByte* addr);		// Delete a multicast address		void			GetLinkIntegrity();						// Get the link integrity flag		void			SetPromiscuous(ULong prom);				// Set promiscuous mode (prom <> 0: enable)		void			GetThroughput();						// Get the driver throughput if available			// Private NE2000 Services		void			TimerExpired(void);						// Called when driver timer expires				//	NE2000 routines		NewtonErr		InitCard();								// Init card		NewtonErr		SetCardInfo();							// Set card info		NewtonErr		NICInit();								// Init NIC		NewtonErr		NICStartRx();							// Start Rx		NewtonErr		NICStartTx(ULong txPage, ULong size);	// Start Tx		NewtonErr		NICStopRxTx();							// Stop Rx and Tx		NewtonErr		NICTxDone();							// Tx done		NewtonErr		NICWaitIdle();							// Wait for idle		ULong			NICWaitStatus(ULong mask, ULong timer);	// Wait for status		NewtonErr		NICRemoteDMAXfer(UChar* buffer, CBufferList* cBufferList, ULong nicBuffer, ULong size, ULong remoteDMAComd);	// Remote DMA xfer		NewtonErr		NICCheckStatus();						// Check status and dispatch it		NewtonErr		NICRxPacketsXfer(ULong returnIfOverflow);// Xfer Rx packets to host		NewtonErr		NICRxBufferOverflow();					// Rx buffer overflow		ULong			NICCheckCardBuffer(ULong expectedSize);	// Check card buffer and return the size in byte		NewtonErr		NICAddDeleteMulticastAddr(UChar* addr, Boolean add);	// Add or delete multicast address		NewtonErr		NICSetPromiscuous(ULong prom);			// Set promiscuous mode (prom <> 0: enable)		Boolean			NICGetLinkIntegrity();					// Get link integrity		ULong			NICGetCurrentRxPage();					// Get current Rx DMA page		NewtonErr		SendPacket(UChar* buffer, CBufferList* cBufferList, ULong packetSize);	// Send packet		ULong			AUTODIN_II_CRC(UChar* data, ULong size);// Do AUTODIN II CRC generation and return 32-bit CRC		void			SetupMFC();								// Set up multi-function card		void			FillBuffer(UChar* buffer, ULong size, ULong startValue);	// Fill buffer with incremental data		//	Internal variables		TMulticastAddrDataBase*	fMulticastAddrDataBase;			// Multicast address data base		TTxPacketQueue*	fTxPacketQueue;							// Tx packets queue				ULong			fStatus;								// Internal status		ULong			fCardConfigBaseAddr;					// Card configuration reg base address		ULong			fNICBaseAddr;							// NIC base address		UChar			fEthernetAddr[kPacketAddrSize];			// Ethernet address		UChar			fMulticastAddrFilterBits[kNICMulticastAddrSize];	// Multicase address filter bits		UChar			fRxPageStart;							// Rx page start 		UChar			fRxPageStop;							// Rx page stop 		UChar			fRxNextPacketPage;						// Rx next packet page		UChar			fInterruptMask;							// Interrupt mask		UChar			fCardConfigNumber;						// Card configuration number 		Boolean			fLinkIntegrity;							// Link integrity staus		Boolean			fTimerPosted;							// Is a timer event posted.		TTime			fTickTime;								// TIme for the next timer event			  #ifdef forDebug		NewtonErr		NICGetTallyCounters();					// Get tally counters		void			DumpBuffer(UChar* buffer, ULong size, ULong startingAddr);	// Dump buffer data		void			FillBuffer(UChar* buffer, ULong size, char* fillString);	// Fill buffer with string		ULong			fDebugSignature;						// Debug signature (locating debug variables in hammer)		ULong			fDebugControls;							// Debug control		UChar			fInterruptStatus;						// Interrupt status		UChar			fRxStatus;								// Rx status		UChar			fTxStatus;								// Tx status		UChar			fRxPacketStatus;						// Rx packet status		UChar			fTxCollisions;							// Tx number of collisons		ULong			fRxErrors;								// Counter for Rx errors		ULong			fRxBufferOverflows;						// Counter for Rx buffer overflows		ULong			fRxBadPageOrSize;						// Counter for Rx bad packet page or size		ULong			fTxErrors;								// Counter for Tx errors		ULong			fTxBufferOverflows;						// Counter for Tx buffer overflows		ULong			fTallyCounterFrameAlignmentErrors;		// Tally counter for frame alignment errors		ULong			fTallyCounterCRCErrors;					// Tally counter CRC errors		ULong			fTallyCounterMissedPacketErrors;		// Tally counter missed packet errors		ULong			fRxCount;								// Rx count		ULong			fTxCount;								// Tx count		ULong			fTxQueuedCount;							// Tx queued count		EventTraceCauseDesc*	fEventTraceCauseDescs;			// Event trace cause descriptors		TEventCollector*		fEventTraceCollector;			// Event trace collector		friend			class	TTxPacketQueue;					// For debugging only, allowing TTxPacketQueue access fEventTraceCollector		friend			class	TCardHandlerNE2K;				// For debugging only	  #endif};////	Internal status definitions//enum kStatus{	kStatusNoStatus						=	0x00000000,			// No status yet	kStatusCardPowerOn					=	0x00000001,			// Card power is truned on by us (need to turn off later)	kStatusNICInited					=	0x00000002,			// NIC is initialized	kStatusCardInfoInited				=	0x00000004,			// Ethernet addr and card buffer is checked	kStatusNIC16Bit						=	0x00000008,			// NIC is operated in 16-bit mode	kStatusDo8BitXferOnly				=	0x00000010,			// Do 8-bit xfer only	kStatusSharedMemoryMode				=	0x00000020,			// Shared memory mode	kStatusEnabled						=	0x00000040,			// Enableded, start Rx or Tx	kStatusTxInProgress					=	0x00000080,			// Tx in progress	kStatusRxPromiscuousMode			=	0x00000100,			// Rx promiscuous mode	kStatus89925Interface				=	0x20000000,			// Winbond W89C925 interface	kStatus3299AInterface				=	0x40000000,			// Tamarack TC3299A interface	kStatus83903Interface				=	0x80000000			// National DP83903 MFC interface};////	Run time debugging controls for selecting different actions at run time without recompile the code//enum kDebugControls{	kDebugControlNoBroadcastPackets		=	0x00010000,	kDebugControlAcceptAllPackets		=	0x00020000,	kDebugControlSaveErrorPackets		=	0x00040000,	kDebugControlRxMonitor				=	0x00080000,	kDebugControlBreakOnRxTxErrors		=	0x00100000,	kDebugControlPrintProgress			=	0x00200000,	kDebugControlTestRx					=	0x01000000,	kDebugControlPrintRxPackets			=	0x02000000,	kDebugControlTestTx					=	0x10000000,	kDebugControlPrintTxQueue			=	0x20000000};////	TMulticastAddrDataBase ////		The multicast address data base keeps track the number of requests for each address//		When the request count of a multicast address reaches 0, the address is removed from NIC chip////	TMulticastAddrEntry////		A multicasr address entry to keep track the number of requests for the address//struct TMulticastAddrEntry{		UChar			fMulticastAddr[kPacketAddrSize];		// Multicast address		UChar			fRequestCount;							// Request count};class TMulticastAddrDataBase{	public:						TMulticastAddrDataBase();						~TMulticastAddrDataBase();		NewtonErr		AddDeleteMulticastAddr(UChar* addr, Boolean add, Boolean* updateNIC);	// Add or delete a multicast address and return current request count		TMulticastAddrEntry*	FindMulticastAddr(UChar* addr);	// Find the multicast addresss in list	private:			CList			fMulticastAddressList;					// TMulticastAddrEntry list};////	TTxPacketQueue	Tx packet queue for buffering Tx packets////		fTxPageStart is the page start of the local Tx buffer on the card//		fTxPageStop is the page stop of the local Tx buffer on the card//		fTxQueuePages is the total number of pages for the Tx buffer//		fTxQueueEmpty indicates the queue is empty or not//		fPacketList points to the list of Tx packets info//			TTxPacketInfo packet info contains packet size, start and stop pages.////		The size of the packet list equals to the number of pages for the Tx buffer.//			This allows the best case to fit each packet in one page.//		There are two indices point to the first and last packets in the packet list.//			The fFirstPacketIndex points to the first packet to be Tx in the queue//				and updated to next packet after the packet is Tx and remove from the queue//			The fLastPacketIndex points to the last packet was added to the queue//			Both indices ranges from 0 to fTxQueuePages - 1////		AddPacket(ULong packetSize, ULong* packetPageStart) adds a Tx packet to the queue.//		RemovePacket() removes a Tx packet from the queue after it Tx complete//		GetNextPacket() retuens next packet for Tx//struct TTxPacketInfo											// Tx packet info{		UShort			fPacketSize;							// Packet size		UChar			fPageStart;								// Packet page start		UChar			fPageStop;								// Packet page stop};class TTxPacketQueue : public SingleObject						// Tx packet queue{	public:						TTxPacketQueue();						// Constuctor						~TTxPacketQueue();						// Destuctor						NewtonErr		Init(ULong txPageStart, ULong txPageStop);				// Init		NewtonErr		AddPacket(ULong packetSize, ULong* packetPageStart);	// Add packet to the end of the queue		NewtonErr		RemovePacket();							// Remove packet from the beginning of the queue		TTxPacketInfo*	GetNextPacket();						// Get next packet from the beginning of the queue		private:		UChar			fTxPageStart;							// Tx queue page start 		UChar			fTxPageStop;							// Tx queue page stop		UChar			fTxQueuePages;							// Tx queue number of pages		UChar			fTxQueueEmpty;							// Tx queue empty		UChar			fFirstPacketIndex;						// First packet index		UChar			fLastPacketIndex;						// Last packet index		TTxPacketInfo*	fPacketList;							// Packet list	  #ifdef forDebug		friend	class	TNE2000Sample;							// For debugging only	  	TNE2000Sample*	fNE2000Sample;							// For accessing fEventTraceCollector in TNE2000Sample		void			DumpTxQueueinfo(char* msg, ULong p0);	// Dump queue info	  #endif};#endif#endif